<?php
/**
 * @var Bold_CheckoutPaymentBooster_Block_Payment_Form_Base $this
 */
?>

<script type="text/javascript">
    /**
     * Bold Payments base class.
     */
    const BoldBase = Class.create({
        boldPaymentsInstance: null,
        authorizedEmail: null,
        fastlaneInstance: null,
        fastlaneProfileData: null,
        gatewayData: null,
        buildFastlaneInstanceInProgress: false,
        isAvailable: <?php echo $this->isAvailable(); ?>,
        groupLabel: '<?php echo $this->getGroupLabel() ?>',
        boldApiUrl: '<?php echo $this->getBoldApiUrl(); ?>',
        jwtToken: '<?php echo $this->getJwtToken(); ?>',
        epsAuthToken: '<?php echo $this->getEpsAuthToken(); ?>',
        epsUrl: '<?php echo $this->getEpsUrl(); ?>',
        epsStaticUrl: '<?php echo $this->getEpsStaticUrl(); ?>',
        epsGatewayId: '<?php echo $this->getEpsGatewayId(); ?>',
        quoteCurrencyCode: '<?php echo $this->getQuoteCurrencyCode(); ?>',
        isFastlaneAvailable: <?php echo $this->isFastlaneAvailable(); ?>,
        paymentId: null,
        billingAddressFieldsMap: {
            'firstname': 'billing:firstname',
            'lastname': 'billing:lastname',
            'company': 'billing:company',
            'telephone': 'billing:telephone',
            'street1': 'billing:street1',
            'street2': 'billing:street2',
            'city': 'billing:city',
            'region_id': 'billing:region_id',
            'country_id': 'billing:country_id',
            'postcode': 'billing:postcode',
            'use_for_shipping': 'billing:use_for_shipping_yes'
        },
        orderDataFieldMapper: {
            'address_id': 'billing-address-select',
            'firstname': 'billing:firstname',
            'email': 'billing:email',
            'lastname': 'billing:lastname',
            'company': 'billing:company',
            'telephone': 'billing:telephone',
            'street1': 'billing:street1',
            'street2': 'billing:street2',
            'city': 'billing:city',
            'region_id': 'billing:region_id',
            'country_id': 'billing:country_id',
            'postcode': 'billing:postcode'
        },
        requiredFields: [
            'email',
            'firstname',
            'lastname',
            'street1',
            'postcode',
            'city',
            'country_id',
            'telephone'
        ],
        orderPayload: {
            'address_id': '<?php echo $this->getAddressId() ?>',
            'email': '<?php echo $this->getCustomerEmail() ?>',
            'firstname': '<?php echo $this->getFirstName() ?>',
            'lastname': '<?php echo $this->getLastName() ?>',
            'company': '<?php echo $this->getCompany() ?>',
            'telephone': '<?php echo $this->getTelephone() ?>',
            'street1': '<?php echo $this->getStreet1() ?>',
            'street2': '<?php echo $this->getStreet2() ?>',
            'city': '<?php echo $this->getCity() ?>',
            'region_id': '<?php echo $this->getRegionId() ?>',
            'country_id': '<?php echo $this->getCountryId() ?>',
            'postcode': '<?php echo $this->getPostcode() ?>',
        },
        /**
         * Initialize class.
         *
         * @returns {*|boolean}
         */
        initialize: async function () {
            if (!this.isAvailable) {
                return false;
            }
            if (!window.bold) {
                window.bold = {
                    orderData: {}
                };
            }
            this.hydrateOrderData();
            this.subscribeToBillingAddressFieldsChanges();
            if (!this.isFastlaneAvailable) {
                return;
            }
            this.renderFastlaneWatermark();
            await this.authorizeFastlaneUser();
            this.subscribeToEmailChanges();
        },
        /**
         * Observe email changes to authorize Fastlane user.
         *
         * @return {void}
         */
        subscribeToEmailChanges: function () {
            const emailField = this.getEmailField();
            if (!emailField) {
                return;
            }
            emailField.observe('change', () => {
                setTimeout(async () => {
                    await this.authorizeFastlaneUser();
                }, 500);
            });
        },
        /**
         * Remove Fastlane watermark placeholder in case fastlane is not available.
         *
         * @return {void}
         */
        removeWatermarkPlaceholder: function () {
            const watermarkContainer = document.getElementById('fastlane-watermark-container');
            if (watermarkContainer) {
                watermarkContainer.remove();
            }
        },
        /**
         * Render Fastlane watermark.
         *
         * @return {void}
         */
        renderFastlaneWatermark: async function () {
            this.renderFastlaneWatermarkPlaceholder();
            const fastlaneInstance = await this.getFastlaneInstance();
            const watermarkComponent = await fastlaneInstance.FastlaneWatermarkComponent({includeAdditionalInfo: true});
            let watermarkContainer = document.getElementById('fastlane-email-watermark-container');
            if (watermarkContainer) {
                watermarkContainer.style = 'float: right';
                watermarkComponent.render('#fastlane-email-watermark-container');
            }
        },
        /**
         * Render Fastlane watermark placeholder to show watermark immediately before fastlane is initialize.
         *
         * @return {void}
         */
        renderFastlaneWatermarkPlaceholder: function () {
            const emailField = this.getEmailField();
            if (!emailField) {
                return;
            }
            const watermarkContainerId = 'fastlane-watermark-container';
            const existingWatermarkContainer = document.getElementById(watermarkContainerId);
            if (existingWatermarkContainer) {
                return;
            }
            const watermarkContainer = document.createElement('div');
            const watermarkSubContainer = document.createElement('div');
            const watermark = document.createElement('img');
            watermarkSubContainer.id = 'fastlane-email-watermark-container';
            watermarkSubContainer.style = 'float: right; margin-top: 5px';
            watermark.src = 'https://www.paypalobjects.com/connect-boba/assets/FastLaneLogoSmall.svg';
            watermark.alt = '';
            watermarkSubContainer.appendChild(watermark);
            watermarkContainer.id = watermarkContainerId;
            watermarkContainer.style = '<?php echo $this->getWatermarkContainerStyle(); ?>';
            watermarkContainer.appendChild(watermarkSubContainer);
            emailField.insertAdjacentElement('afterend', watermarkContainer);
        },
        /**
         * Build Fastlane Instance considering gateway type.
         *
         * @return {Promise<{}>}
         */
        getFastlaneInstance: async function () {
            if (this.fastlaneInstance) {
                this.buildFastlaneInstanceInProgress = false;
                return this.fastlaneInstance;
            }
            if (this.buildFastlaneInstanceInProgress) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        resolve(this.getFastlaneInstance());
                    }, 500);
                });
            }
            this.buildFastlaneInstanceInProgress = true;
            const boldPaymentsInstance = await this.getBoldPaymentsInstance();
            //this.gatewayData = (await boldPaymentsInstance.getFastlaneClientInit())[this.epsGatewayId] || null;
            const response = await fetch(
                encodeURI(this.epsUrl + '/' + this.groupLabel + '/client_init?option=fastlane'),
                {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
            this.gatewayData = (await response.json())[this.epsGatewayId] || null;
            if (!this.gatewayData) {
                return null;
            }
            if (this.gatewayData.is_test_mode) {
                window.localStorage.setItem('axoEnv', 'sandbox');
                window.localStorage.setItem('fastlaneEnv', 'sandbox');
            }
            if (this.gatewayData.type === 'braintree') {
                this.fastlaneInstance = await this.buildBraintreeFastlaneInstance();
            }
            if (this.gatewayData.type === 'ppcp') {
                this.fastlaneInstance = await this.buildPpcpFastlaneInstance();
            }
            this.buildFastlaneInstanceInProgress = false;
            return this.fastlaneInstance;
        },
        /**
         * Build Fastlane Instance for the Braintree.
         *
         * @return {Promise<void>}
         */
        buildBraintreeFastlaneInstance: async function () {
            await this.loadScript(
                'https://js.braintreegateway.com/web/3.101.0-fastlane-beta.7.2/js/client.min.js'
            );
            await this.loadScript(
                'https://js.braintreegateway.com/web/3.101.0-fastlane-beta.7.2/js/data-collector.min.js'
            );
            await this.loadScript(
                'https://js.braintreegateway.com/web/3.101.0-fastlane-beta.7.2/js/hosted-fields.min.js'
            );
            await this.loadScript(
                'https://js.braintreegateway.com/web/3.101.0-fastlane-beta.7.2/js/fastlane.min.js'
            );
            const clientInstance = await window.braintree.client.create({
                authorization: this.gatewayData.client_token,
            });
            const dataCollectorInstance = await window.braintree.dataCollector.create(
                {
                    client: clientInstance,
                }
            );
            const {deviceData} = dataCollectorInstance;
            return window.braintree.fastlane.create({
                authorization: this.gatewayData.client_token,
                client: clientInstance,
                deviceData: deviceData,
            });
        },
        /**
         * Build Fastlane Instance for the PPCP.
         *
         * @return {Promise<void>}
         */
        buildPpcpFastlaneInstance: async function () {
            console.log('Building PPCP Fastlane instance');
            const debugMode = this.gatewayData.is_test_mode ? '&debug=true' : '';
            await this.loadScript(
                `https://www.paypal.com/sdk/js?client-id=${this.gatewayData.client_id}&components=fastlane${debugMode}`,
                {
                    'data-user-id-token': this.gatewayData.client_token,
                    'data-client-metadata-id': this.publicOrderId,
                }
            );
            return window.paypal.Fastlane();
        },
        /**
         * Authorize user with email.
         *
         * @return {Promise<void>}
         */
        authorizeFastlaneUser: async function () {
            const emailField = this.getEmailField();
            if (!emailField || !emailField.value || this.authorizedEmail === emailField.value) {
                return;
            }
            if (!window.Validation.validate(emailField)) {
                return;
            }
            checkout.setLoadWaiting('billing', true);
            this.authorizedEmail = emailField.value;
            try {
                const {identity} = await this.getFastlaneInstance();
                const {customerContextId} = await identity.lookupCustomerByEmail(emailField.value);
                checkout.setLoadWaiting(false);
                if (!customerContextId) {
                    this.removeAddressButton();
                    this.fastlaneProfileData = null;
                    if (window.boldFastlaneInstance) {
                        window.boldFastlaneInstance.renderFastlanePaymentComponent();
                    }
                    return;
                }
                const {
                    authenticationState,
                    profileData
                } = await identity.triggerAuthenticationFlow(customerContextId);
                if (authenticationState === 'succeeded') {
                    checkout.setLoadWaiting('billing', true);
                    this.profileData = profileData;
                    if (profileData.shippingAddress) {
                        this.updateBillingAddress(profileData.shippingAddress);
                        this.addAddressButton();
                    }
                    if (window.boldFastlaneInstance) {
                        window.boldFastlaneInstance.selectPaymentMethod();
                        window.boldFastlaneInstance.renderFastlanePaymentComponent();
                    }
                    checkout.setLoadWaiting(false);
                }
            } catch (error) {
                console.error('Error:', error);
            }
        },
        /**
         * Set Fastlane shipping address as Magento shipping address.
         *
         * @param {{}} fastlaneAddress
         * @return {void}
         */
        updateBillingAddress: function (fastlaneAddress) {
            const magentoAddress = this.convertFastlaneAddressToMagentoAddress(fastlaneAddress);
            Object.keys(this.billingAddressFieldsMap).forEach((field) => {
                if (magentoAddress[field] && document.getElementById(this.billingAddressFieldsMap[field])) {
                    const element = document.getElementById(this.billingAddressFieldsMap[field]);
                    if (!element) {
                        return;
                    }
                    element.value = magentoAddress[field];
                }
            });
            this.hydrateOrderData();
        },
        /**
         * Convert Fastlane address to Magento address.
         *
         * @param fastlaneAddress
         * @return {{}}
         */
        convertFastlaneAddressToMagentoAddress: function (fastlaneAddress) {
            let magentoAddressRegionId = null;
            const fastlaneCountryCode = fastlaneAddress.countryCodeAlpha2 || fastlaneAddress.address?.countryCode;
            const fastlaneRegionCode = fastlaneAddress.region || fastlaneAddress.address?.adminArea1;
            if (window.billingRegionUpdater.regions[fastlaneCountryCode]) {
                Object.entries(window.billingRegionUpdater.regions[fastlaneCountryCode]).each((region) => {
                    const [regionId, regionData] = region;
                    if (regionData.code === fastlaneRegionCode) {
                        magentoAddressRegionId = regionId;
                    }
                })
            }
            const telephone = typeof fastlaneAddress.phoneNumber === 'string'
                ? fastlaneAddress.phoneNumber
                : fastlaneAddress.phoneNumber?.countryCode + fastlaneAddress.phoneNumber?.nationalNumber;
            return {
                'firstname': fastlaneAddress.firstName || fastlaneAddress.name?.firstName,
                'lastname': fastlaneAddress.lastName || fastlaneAddress.name?.lastName,
                'company': fastlaneAddress.company,
                'telephone': telephone,
                'street1': fastlaneAddress.streetAddress || fastlaneAddress.address?.addressLine1,
                'street2': fastlaneAddress.extendedAddress || fastlaneAddress.address?.addressLine2,
                'city': fastlaneAddress.locality || fastlaneAddress.address?.adminArea2,
                'region_id': magentoAddressRegionId,
                'postcode': fastlaneAddress.postalCode || fastlaneAddress.address?.postalCode,
                'country_id': fastlaneCountryCode,
            };
        },
        /**
         * Remove change address button from billing address form.
         *
         * @return {void}
         */
        removeAddressButton: function () {
            const fastlaneAddressContainer = document.getElementById('fastlane-address-container');
            if (fastlaneAddressContainer) {
                fastlaneAddressContainer.remove();
            }
        },
        /**
         * Add change address button on billing address form.
         *
         * @return {{}}
         */
        addAddressButton: function () {
            this.removeAddressButton();
            const fastlaneAddressContainer = document.createElement('fieldset');
            fastlaneAddressContainer.id = 'fastlane-address-container';
            fastlaneAddressContainer.style = '<?php echo $this->getAddressContainerStyle(); ?>';
            const updateAddressButton = document.createElement('button');
            updateAddressButton.type = 'button';
            updateAddressButton.className = 'button';
            updateAddressButton.innerHTML = 'Change Address';
            updateAddressButton.addEventListener('click', () => {
                this.getFastlaneInstance().then((fastlaneInstance) => {
                    if (!fastlaneInstance) {
                        return;
                    }
                    fastlaneInstance.profile.showShippingAddressSelector().then((editAddressResult) => {
                        if (!editAddressResult.selectionChanged) {
                            return;
                        }
                        this.updateBillingAddress(editAddressResult.selectedAddress);
                    });
                });
            });
            fastlaneAddressContainer.appendChild(updateAddressButton);
            const billingAddressForm = document.getElementById('billing-new-address-form');
            if (billingAddressForm) {
                billingAddressForm.appendChild(fastlaneAddressContainer);
            }
        },
        /**
         * Load SPI SDK.
         *
         * @returns {Promise<void>}
         */
        getBoldPaymentsInstance: async function () {
            if (this.boldPaymentsInstance) {
                return this.boldPaymentsInstance;
            }
            await this.loadScript(this.epsStaticUrl + '/js/payments_sdk.js');
            const initialData = {
                'eps_url': this.epsUrl,
                'eps_bucket_url': this.epsStaticUrl,
                'group_label': this.groupLabel,
                'trace_id': '<?php echo $this->getPublicOrderID(); ?>',
                'payment_gateways': [
                    {
                        'gateway_id': Number(this.epsGatewayId),
                        'auth_token': this.epsAuthToken,
                        'currency': this.quoteCurrencyCode,
                    }
                ],
                'callbacks': {
                    'onCreatePaymentOrder': async function (paymentType, paymentPayload) {
                        if (paymentType !== 'ppcp') {
                            return;
                        }
                        const walletPayResult = await fetch(this.boldApiUrl + 'wallet_pay/create_order', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer ' + this.jwtToken,
                            },
                            body: JSON.stringify(paymentPayload),
                        });
                        if (walletPayResult.ok) {
                            const walletPayResultPayload = await walletPayResult.json();
                            return walletPayResultPayload.data
                        }
                        throw 'Unable to create wallet pay order';
                    }.bind(this),
                    'onUpdatePaymentOrder': async function () {
                        // We won't handle updating an order from PayPal data, we will disable address changes etc
                    }.bind(this),
                    'onApprovePaymentOrder': async function (paymentType, paymentInformation) {
                        // A PayPal payment has been completed, we need to capture the payment ID and pass it through
                        if (paymentType !== 'ppcp') {
                            return;
                        }
                        if (!paymentInformation.payment_id) {
                            console.error('No payment ID provided from PayPal.');
                            return;
                        }
                        window.bold.paymentId = paymentInformation.payment_id;
                        payment.save();
                    }.bind(this),
                    'onScaPaymentOrder': async function (type, payload) {
                        if (type !== 'ppcp') {
                            throw new Error('Unsupported payment type');
                        }
                        const url = `${this.boldApiUrl}payments/on_sca`;
                        const orderId = payload.order_id;
                        const scaResult = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.jwtToken}`
                            },
                            body: JSON.stringify(
                                {
                                    'order_id': orderId,
                                    'public_order_id': '<?php echo $this->getPublicOrderID(); ?>',
                                    'gateway_type': 'ppcp',
                                }
                            ),
                        });
                        if (!scaResult.ok) {
                            throw new Error('SCA failed');
                        }
                        const data = await scaResult.json();
                        return {card: data};
                    }.bind(this)
                }
            };
            this.boldPaymentsInstance = new window.bold.Payments(initialData);
            return this.boldPaymentsInstance;
        },
        /**
         * Load specified script with attributes.
         *
         * @returns {Promise<void>}
         */
        loadScript: async function (src, attributes = {}) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = resolve;
                script.onerror = reject;
                if (attributes.constructor === Object) {
                    Object.keys(attributes).forEach((key) => {
                        script.setAttribute(key, attributes[key]);
                    });
                }
                document.head.appendChild(script);
            });
        },
        /**
         * Subscribe to fields changes for order hydration.
         *
         * @returns {void}
         */
        subscribeToBillingAddressFieldsChanges: function () {
            Object.values(this.orderDataFieldMapper).each(function (selector) {
                let field = $(selector);
                if (field) {
                    field.observe('change', () => {
                        setTimeout(() => {
                            this.hydrateOrderData();
                        }, 500);
                    });
                }
            }.bind(this));
        }
        ,
        /**
         * Update order data payload for order hydration call.
         *
         * @returns {void}
         */
        updateOrderDataPayload: function () {
            Object.keys(this.orderDataFieldMapper).forEach(function (key) {
                let field = this.orderDataFieldMapper[key];
                if ($(field)) {
                    this.orderPayload[key] = $(field).value;
                }
            }.bind(this));
        }
        ,
        /**
         * Validate order data payload for hydration.
         *
         * @returns {boolean}
         */
        isPayloadValid: function () {
            let isInvalid = this.requiredFields.some((field) => {
                return !this.orderPayload[field];

            });
            if (isInvalid) {
                return false;
            }
            let regionsRequired = window.billingRegionUpdater || {
                config: {
                    regions_required: []
                }
            };
            let isRegionRequired = regionsRequired.config.regions_required.indexOf(this.orderPayload.country_id) !== -1;
            if (isRegionRequired && !this.orderPayload.region_id) {
                return false;
            }
            return !isInvalid;
        },
        /**
         * Check if already hydrated payload differs from new one.
         *
         * @returns {boolean}
         */
        isPayloadChanged: function () {
            if (!window.bold.orderData) {
                return true;
            }
            let isChanged = false;
            for (let [key, value] of Object.entries(this.orderPayload)) {
                if (window.bold.orderData[key] !== value) {
                    isChanged = true;
                    break;
                }
            }
            return isChanged;
        },
        /**
         * Hydrate Bold order.
         */
        hydrateOrderData: function (force = false) {
            if (Ajax.activeRequestCount > 0) {
                this.hydrateOrderData.bind(this).delay(0.1);
                return;
            }
            this.updateOrderDataPayload();
            if (!this.isPayloadValid()) {
                return;
            }
            if (!this.isPayloadChanged() && !force) {
                return;
            }
            new Ajax.Request('/checkoutpaymentbooster/index/hydrateOrderData', {
                method: 'post',
                parameters: Object.assign(
                    this.orderPayload,
                    {
                        form_key: '<?php echo Mage::getSingleton('core/session')->getFormKey() ?>'
                    }
                ),
                onSuccess: function () {
                    if (this.orderPayload.region_id) {
                        const region = billingRegionUpdater.regions[this.orderPayload.country_id][this.orderPayload.region_id] || null;
                        if (region) {
                            this.orderPayload.region = region.code;
                        }
                    }
                    window.bold.orderData = Object.assign({}, this.orderPayload);
                }.bind(this),
                onFailure: function () {
                    if (typeof window.bold.FastlaneInstance !== 'undefined') {
                        window.bold.FastlaneInstance.hidePaymentMethod();
                    }
                    checkout.setLoadWaiting(false);
                    window.bold.orderData = {};
                    console.error('Failed to sync order data');
                }.bind(this),
            });
        },
        /**
         * Send tokenize action to SPI iframe.
         *
         * @return {Promise<void>}
         */
        tokenize: async function () {
            const iframeWindow = document.getElementById('spi_frame_payment_form_bold').contentWindow;
            const payload = {
                billing_address: {
                    first_name: window.bold.orderData.firstname,
                    last_name: window.bold.orderData.lastname,
                    address_line_1: window.bold.orderData.street1,
                    address_line_2: window.bold.orderData.street2,
                    province_code: window.bold.orderData.region,
                    city: window.bold.orderData.city,
                    postal_code: window.bold.orderData.postcode,
                    country_code: window.bold.orderData.country_id,
                }
            };
            iframeWindow.postMessage({actionType: 'ACTION_SPI_TOKENIZE', payload: payload}, '*');
        },
        /**
         * Get email field.
         *
         * @return {HTMLElement}
         */
        getEmailField: function () {
            return document.getElementById('billing:email');
        }
    });
    document.observe('dom:loaded', function () {
        if (typeof window.bold === 'undefined') {
            window.bold = {};
        }
        window.bold.baseInstance = new BoldBase();
    });
</script>
